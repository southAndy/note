#vue2

### 原理解釋

在 vue 畫面是否渲染是與狀態綁定，在 vue2 是透過 `Object.defineProperty` 追蹤狀態是否改變，透過這個方法可以加入 `get`, `set` 屬性，設定當key值被存入或讀取要執行的動作。

我們模擬實例中的 `data` ，當我們在裡面新增幾個狀態值
```js
//vue 實例中的狀態
const data = {
	message:'',
	isClick:false
}
```

每個狀態發生改變時會能觸發畫面重新渲染，就是因為它背後機制如下

```js
//假設是 `message`
Object.defineProperty(data,key,{
	set(val){
		//當更新狀態值時
		if(val !== ){
			//存入新值
			this.meesage = val
			//會通知 watcher 實例去更新畫面
			watcher()
		}
	},
	get(){
		return this.message
	}
})
```

自己理解**這個響應性函式只會在元件初始化時執行**，所以後續新增到 `data` 的內容不會觸發響應式，在 vue2 可以直接對實例添加新的值，但這樣新增的值並不會被加入追蹤，所以更新不會觸發渲染。

針對這個問題有兩個方向的解決方法：

1. 限制實例添加值的方式，避免錯誤的新增
2. 讓添加的值具有響應性

```js
const vm = new Vue({
	data:{
		meesage:''
	}
})
vm.message = '1' //reactive successful
vm.newValue = '' //reactive failure
```


### 讓添加值具有響應性

當你希望幫某個物件新增 key 值時，vue2 提供了 `$set` API 解決這個問題

```js

data:()=>{
	return {
		obj:{}
	}
}
//幫此物件新增屬性
this.$set(this.obj,'cool',123)
```




### 如何避免錯誤添加方式

可以使用 `Object.freeze` 避免實例以原生方式新增資料
```js
const data = {
	a:1
}
//使用 object.freeze 凍結
const constantData = Object.freeze(data)

//將這個 constantData 加入

let vm = new Vue({
	data:constantData
});

vm.newProperty = '1' //可執行但無法實際加入新屬性
```

---
### 參考

1. https://v2.vuejs.org/v2/guide/reactivity.html