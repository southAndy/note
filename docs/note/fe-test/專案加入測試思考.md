
## 加入時機

越早越好，在你的架構初期元件功能耦合依賴性仍不高時。


## 選擇測試目標的依據
### 需考量專案時間情境

優先替 **產品核心功能** 添加測試，保證穩定度

## 單元測試

[[unit test]]

## 元件測試
假設今天是要測試一個共用元件，以下是我自己目前會進行的測試面向：

1. 元件的基本運行
	1. 是否能正常渲染？
	2. `props` 都能確實傳遞
	3. 綁定事件能觸發
2. 行為測試
	1. 預設的 `hover` 樣式，可以透過測試確認實際運作的顯示樣式是否如預期
	2. 按鈕狀態為 `disabled` 時，應該不能觸發點擊事件
	3. 狀態改變是否跟 `props` 連動
 

加入 typescript 後可以減除一些測試情境，例如傳入 `undefined` 作爲 `props` 值怎麼辦？這在型別編譯階段就會報錯，就可以免去額外撰寫測試的必要

## 快照測試

### 確認狀態與畫面載入樣式

進行快照測試會需要模擬瀏覽器 DOM 的渲染，因此還需要再引入套件去實現，這邊使用 *jsdom* 這個套件

```js
//vite.config.js

export default {
	test:{
		enviroment:jsdom
	}
}
```

#### 發現問題

元件對外依賴太多，造成單元測試很困難，因為要模擬的外部依賴同時增加

## 整合測試

### 畫面載入效果與狀態綁定



----

## 未整理思考問題

這邊存放了一些自己開始撰寫測試後產生的疑惑，後續如果有一點心得會整理出去

```
測試檔案位置要放哪？統一管理在 `/tests` 底下？或是隨著被測試內容一同放置
如果同時有做單元測試、整合測試，那檔案怎麼命名好？
測試風格該混用嗎？ 是根據測試情境複雜度混合使用 GWT, it Should ？
自己開始寫測試之後，進到開發有什麼不同的考量出現嗎？
```

## 情境

### 定義單一功能

以我專案中的 vuex 內的  `actions` 來說，這個函式執行會觸發兩個行為：

1. 打 api 發出請求索取資料 
2. 成功後，呼叫 `mutations` 去更新 `state`

```js
actions:{
	async getApi({commit}){
		const data = await callApi();
		commit("storeData",data)
	}
}
```

回顧單元測試的兩個核心原則，分別是
1. **測試單一功能、任務**
2. **隔絕依賴**

檢視 `getApi` 這個方法來說，它的功能就是負責完成上述兩件事，這時重新檢視單元測試「單一功能能運作」的概念，產生了疑惑「但這個函式實際做了很多事情，怎麼叫單一？」，所謂的單一功能，不代表只做一件事？

自己的理解有點像是我們要燉牛肉，但其實過程要經過切肉、切菜、炒料，全部過程都有確實完成，才能順利完成燉牛肉。

「隔絕依賴」的部分，以這個案例來說就是與外部有依賴的是「真實 API 請求及真實的 vuex」，所以：
3. 避免請求真實 API : 因為牽涉到網路環境、以及資料庫等不可控因素
4. 避免操作真實 vuex：可以避免副作用的產生，例如測試過程改到真正的狀態


綜合上述，我們得知要做：
5. 模擬 API 
6. 模擬 mutations

透過 vitest 提供的 `vi` 可以實現模擬 API 這件事，它可劫持透定路徑檔案內的函式，並可自定義回傳值、錯誤內容，以這個專案來說 API 呼叫的設定是統一放在 `/service/getApi.js` 

```js
//service/getApi.js

//創立一個axios的實例，統一提供app使用
const touristAPI = axios.create({
//baseURL:要一直被呼叫的API
baseURL: "https://ptx.transportdata.tw/MOTC/v2/Tourism/",
headers: {
Accept: "application/json",

//加密函式
...getAuthorizationHeader(),},
});
export default {
	getScenicSpotAPI() {
	return touristAPI.get("/ScenicSpot?%24top=500&%24format=JSON");},
}
```
我們在測試檔案引入這個模組後，使用 `vi` 進行劫持，並透過 `mock` , `mock`

```js
//action.unit.test.js
import {vi} from "vitest"
import API from "/service/getApi.js"

//使用 mock 進行劫持
vi.mock('/service/getApi.js',()=>{
	default{
	// 自定義回傳值
	getScenicSpotAPI:vi.fn().mockResolvedValue({data:12})
	}
})
```

所謂的劫持，自己理解是 **呼叫目標函式時，會觸發額外的行為**，可以用 `Proxy` 的概念去理解。