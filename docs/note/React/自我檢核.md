#react 

- **說明 vue 跟 react 的差異**：
	- 
	- 框架生態系的使用彈性（ vue 官方提供推薦的套件，能應對多數的情境，但是遭遇更客製化的情境較不方便）
	- 是否有提供明確生命週期 API 供開發者使用（ react 沒有）
	- vue 提供數據雙向綁定的方法 `v-model` （**好處是**）
- **請幫我們分享並解釋，當呼叫 `setState` 方法到畫面完成重新渲染，中間發生了哪些事情？**：
	- 當你使用 `setState` 方法對一個狀態進行調整時，會提示 React 要進行重新渲染，進到所謂的 *Reconima* 的階段 但是 React 並不會去追蹤狀態改變的位置，而是會執行元件相關內容的 **完整重渲染**
- **batch update 的延伸情境理解**： 是 React 為了避免不必要的 re-render 新增的機制，開發者可以用 `flushSync` 去在特定情境解除 batching update 的機制，實現即刻同步更新。
- **請說明元件有哪些生命週期**：在 function component 內並沒有明確的生命週期 API ，但是元件主要還是有 **mout** , **update**, **unmount** 三個週期
- **對於 useEffect 的使用理解**
	- `useEffect` vs `useLayoutEffect` ：瀏覽器 DOM 渲染完成後 vs 虛擬 DOM 渲染完成
	- clean function 觸發時機：清除前一次渲染產生的副作用後，再執行新的副作用
- **Redux** 
	- 什麼是 Redux ？為何需要它？
	- Redux 的資料流
- **如何決定要使用 Redux 還是 ContextAPI**：
	- 
- **React 效能優化的方法**：
	- `useMemo` , `React.memo()`
	- `useCallback`
- **Redux vs RTK 差在哪？**
	- (RTK) 低繁瑣 store 實例設置（不需手動合併 reducer、添加 middleware, devtools 等配置）
	- (RTK) 不處理非同步邏輯需手動安裝 redux-thunk
	- (RTK) 不需手動撰寫 *action-type* , *creators*

```js
//redux 
// store.js
import { createStore, applyMiddleware, combineReducers } from 'redux';
import thunk from 'redux-thunk';
import { composeWithDevTools } from 'redux-devtools-extension';
import counterReducer from './counterReducer';

// 手動合併 reducers
const rootReducer = combineReducers({
  counter: counterReducer,
});

// 手動設定 store + middleware + devtools
const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware(thunk))
);

export default store;


//RTK
// store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

// 簡化設定，內建支援 thunk 和 devtools
const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});

export default store;
```
- *Reconciliation* 代表的是什麼 => update (diffing)
- 為什麼選用 Redux 而不是 Context API？

### 觀念線上測試
1. https://bigfrontend.dev/
2. https://github.com/sudheerj/reactjs-interview-questions?tab=readme-ov-file#table-of-contents


### 效能優化

- 有哪些方式進行效能優化？